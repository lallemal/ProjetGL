class MatriceFloat extends AbstractMatrice{
    float[][] matfloat;

    void setInit(float[][] mat, int nbl, int nbc) {
        this.nbl = nbl;
        this.nbc = nbc;
        this.matfloat = mat;
    }
    // initialise a partir d'un tableau de int creer une copie
    void setInitInt(int[][] mat, int nbl, int nbc) {
        int i = 0;
        int j = 0;
        this.nbl = nbl;
        this.nbc = nbc;
        this.matfloat = new float[nbl][nbc];
        while(i < nbl) {
            while(j < nbc) {
                (this.matfloat)[i][j] = mat[i][j];
                j = j + 1;
            }
            j = 0;
            i = i + 1;
        }

    }
    void setInitFloat(float[][] mat, int nbl, int nbc) {
        int i = 0;
        int j = 0;
        this.nbl = nbl;
        this.nbc = nbc;
        this.matfloat = new float[nbl][nbc];
        while(i < nbl) {
            while(j < nbc) {
                (this.matfloat)[i][j] = mat[i][j];
                j = j + 1;
            }
            j = 0;
            i = i + 1;
        }
    }
    // cree un vecteur de taille (n,1) de 1
    void setOneVector(int n){
        float[][] mat;
        int i = 0;
        this.nbl = n;
        this.nbc = 1;
        mat = new float[this.nbl][1];
        while(i < this.nbl) {
            mat[i][0] = 1;
            i = i + 1;
        }
        this.matfloat = mat;
    }
    void setIndentite(int n) {
        float[][] t; 
        int i = 0;
        int j = 0;
        this.nbl = n;
        this.nbc = n;
        t = new float[n][n];
        while(i < n) {
            while(j < n) {
                if (i == j) {
                    t[i][j] = 1;
                }
                else {
                    t[i][j] = 0;
                }
                j = j + 1;
            }
            j = 0;
            i = i + 1;
        }
        this.matfloat = t;
    }

    float getCase(int i, int j) {
        return (this.matfloat)[i][j];
    }



    void affichage() {
        int l = 0;
        int c = 0;
        float resultat = 0;
        print("[");
        while(l < this.nbl) {
            while( c < this.nbc){
                if (l == 0 && c == 0) {
                    resultat = (this.matfloat)[l][c];
                    print("[" , resultat);
                }
                else if (l > 0 && c == 0) {
                    resultat = (this.matfloat)[l][c];
                    print(" [", resultat);
                }
                else{
                    resultat = (this.matfloat)[l][c];
                    print(" " , resultat);
                }
                c = c + 1;
                if (c < nbc) {
                    print(",");
                }
            }
            print("]");
            if (l < nbl -1) {
                println(",");
            }
            c = 0;
            l = l + 1;
        }
        println("]");
    }

    MatriceFloat sumMat(MatriceFloat m) {
        float [][] tabfinal;
        MatriceFloat matfinal;
        int i = 0;
        int j = 0;
        if (this.nbc != m.getNbc() && this.nbl != m.nbl) {
            return null;
        }
        tabfinal = new float[this.nbl][m.getNbc()];
        matfinal = new MatriceFloat();
        matfinal.setInit(tabfinal, this.nbl, m.getNbc());
        while(i < this.nbl) {
            while (j < this.nbc) {
                tabfinal[i][j] = (this.matfloat)[i][j] + m.getCase(i, j);
                j = j + 1;
            }
            j = 0;
            i = i + 1;
        }
        return matfinal;
    }

    MatriceFloat transpose() {
        float[][] tab; 
        MatriceFloat transpose;
        int i = 0;
        int j = 0;
        tab = new float[this.getNbc()][this.getNbl()];
        while (i < this.nbc) {
            while(j < this.nbl) {
                tab[i][j] = this.getCase(j, i);
                j = j + 1;
            }
            j = 0;
            i = i + 1;
        }
        transpose = new MatriceFloat();
        transpose.setInit(tab, this.getNbc(), this.getNbl());
        return transpose;
    }



    /* algorithme utilse pivot de Gauss transforme la matrice directement*/

    // echange deux lignes
    void echange(int li, int  lj) {
        int i = 0;
        float[] copieligne = new float[this.getNbc()];
        while (i < this.nbc) {
            copieligne[i] = (this.matfloat)[li][i];
            i = i + 1;
        }
        i = 0;
        // copie de lj dans li
        while (i < this.nbc) {
            (this.matfloat)[li][i] = (this.matfloat)[lj][i];
            i = i + 1;
        }
        i = 0;
        // copie de li dans lj
        while (i < this.nbc) {
            (this.matfloat)[lj][i] = copieligne[i];
            i = i + 1;
        }
    }

    // multiplication par un scalaire non nul renvoi false si echoue
    boolean multScal(int li, float scalaire) {
        int i = 0;
        if(scalaire == 0) {
            return false;
        }
        while(i < this.nbc) {
            (this.matfloat)[li][i] = (this.matfloat)[li][i]* scalaire;
            i = i + 1;
        }
        return true;
    }


    // ajout du multiple par une autre ligne ex: L1 <- L1 + x*L2
    void addMultLine(int lmodif, int lscal, float scalaire) {
        int i = 0;
        while(i < this.nbc) {
            (this.matfloat)[lmodif][i] = (this.matfloat)[lmodif][i] +(this.matfloat)[lscal][i] * scalaire;
            i = i + 1;
        }
    }

    // retourne la valeur absolue du flottant
    float absolue (float i) {
        float res = i;
        if (i < 0) {
            res = -i;
        }
        return res;
    }

    // tourve la ligne  dans colonne i avec la valeur aboslue la plus grand 
    //retourne l'indice de ligne le plus grand
    int indicePivot(int icolonne, int r) {
        float compare;
        int i = r+1;
        // indice du max
        int indice = i;
        float max = this.absolue((this.matfloat)[i][icolonne]);
        while(i < this.nbl) {
            compare = this.absolue((this.matfloat)[i][icolonne]);
            if(max < compare) {
                indice = i;
            }
            i = i + 1;
        }
        return indice;
    }




}

